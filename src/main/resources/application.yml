spring:
  application:
    name: whereq-libra

server:
  port: 8080
  # Note: WebFlux does not use servlet context path
  # Use spring.webflux.base-path if needed for path prefix

# Spark Configuration
spark:
  app-name: whereq-libra
  master: local[*]  # Can be overridden for cluster deployment
  config:
    spark.driver.memory: 2g
    spark.executor.memory: 2g
    spark.sql.warehouse.dir: /tmp/spark-warehouse
    spark.driver.host: localhost

    # Enable FAIR scheduler for parallel job execution
    spark.scheduler.mode: FAIR
    # Note: fairscheduler.xml path will be set programmatically in SparkSessionManager
    # to handle classpath resources properly

# Libra-specific configuration
libra:
  session:
    # Session management mode: SHARED or ISOLATED
    # SHARED: Single SparkSession for all requests (better performance)
    # ISOLATED: One SparkSession per user/session (better isolation)
    mode: SHARED

    # Maximum number of concurrent sessions (for ISOLATED mode)
    max-sessions: 10

    # Session timeout in minutes
    timeout-minutes: 30

    # Enable session pooling
    pooling:
      enabled: false
      min-size: 2
      max-size: 10

  # Phase 1: Async execution configuration
  execution:
    modes:
      in-cluster:
        enabled: true
        limits:
          max-executors: 5
          max-memory-per-executor: 4g
          max-cores-per-executor: 2
          max-concurrent-jobs: 10

      spark-submit:
        enabled: true
        spark-home: /opt/spark
        timeout-minutes: 60

      kubernetes:
        enabled: false
        namespace: spark-jobs
        service-account: spark-operator
        image: spark:4.0.1
        ttl-seconds-after-finished: 3600

  # Resource management
  resources:
    limits:
      cpu-cores: ${K8S_CPU_LIMIT:16}
      memory-gb: ${K8S_MEMORY_LIMIT:64}
      max-concurrent-jobs: 10

    monitor:
      enabled: true
      poll-interval: 5000  # milliseconds
      alert-threshold:
        cpu-percent: 90
        memory-percent: 90

  # Job queue configuration
  queue:
    type: redis  # redis, postgresql, memory
    persistence: true
    max-size: 1000
    max-wait-time-minutes: 30

  # Retry configuration
  retry:
    max-attempts: 3
    backoff:
      initial-interval-ms: 1000
      multiplier: 2
      max-interval-ms: 60000

# Redis configuration (for job queue)
spring:
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    timeout: 5000ms
    lettuce:
      pool:
        max-active: 20
        max-idle: 10
        min-idle: 5

# Management and Actuator
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always

# API Documentation
springdoc:
  api-docs:
    path: /api-docs
  swagger-ui:
    path: /swagger-ui.html
    enabled: true

# Logging
logging:
  level:
    root: INFO
    com.whereq.libra: DEBUG
    org.apache.spark: WARN
    org.apache.hadoop: WARN
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
